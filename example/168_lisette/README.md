| file  | description                                                         |
|-------|---------------------------------------------------------------------|
| gen01 | simple test                                                         |
| gen02 | tool use (reading directory listings, files and searching for text) |
|       |                                                                     |


### **Example 168: Analyzing a Codebase with a Gemini Agent**

This example was created for the homework in Lecture 2 of Jeremy Howard's 'How To Solve It With Code' course (2025). It demonstrates the lecture's concepts by using an LLM agent with filesystem tools to analyze a codebase, adapted here to use Google's Gemini model via the `lisette` library.

#### **Motivation**

I'm really interested in using LLMs to help understand legacy codebases. This experiment is a practical attempt to do just that: point an agent at an old project of mine and see if it can produce a useful summary.

#### **Implementation**

*   **Agent:** This code uses `lisette` instead of `claudette`, primarily because I have a free and generous Gemini API key. The switch between the two libraries is straightforward.
*   **Tools:** As described in the lecture, the agent is given access to filesystem tools (`rg`, `set` and `view` from `fastcore.tools`) to list directories and read files.
*   **Target:** The agent was run on one of my old Git repositories (this one), a place where I occasionally add new experiments.

The full script can be found in `p02_fs_tools.py`.

#### **Results and Observations**

The agent produced the overview found in `output2.md`. I was impressed; it's a nice summary of the project structure.

##### Contents of output2.md:

The `cl-py-generator` project is a Common Lisp tool designed to transpile s-expressions into Python code.

**Project Summary:**
The `README.md` details the supported s-expression forms, which cover a broad range of Python constructs:
*   **Data Structures:** `tuple`, `paren`, `ntuple`, `list`, `curly` (for sets/dicts), `dict`, `dictionary` (using `dict()` constructor).
*   **Control Flow & Definitions:** `indent`, `do`, `do0`, `cell`, `export`, `lambda` (anonymous functions), `def` (function definition), `class`.
*   **Assignments & Operations:** `setf` (assignment), `incf` (increment), `decf` (decrement), `aref` (array/list indexing), `slice` (slicing), `dot` (attribute access).
*   **Operators:** `+`, `-`, `*`, `@` (decorator/matrix multiplication), `==`, `!=`, `<`, `>`, `<=`, `>=`, `<<` (left shift), `>>` (right shift), `/`, `**` (exponentiation), `//` (floor division), `%` (modulo), `and`, `or`, `&` (bitwise AND), `logand`, `logxor`, `logior`.
The documentation notes that the form descriptions were initially generated by ChatGPT-4 and may require review.

**Examples Overview:**
The `README.org` lists numerous examples, indicating a wide application scope:
*   **GUI & Visualization:** Matplotlib plotting (`plot`), various Qt versions (`qt`, `qt_customplot`, `qt_webkit`, `qt_webengine`, `vulkan_qt`, `pyqt6`), Tkinter (`tkinter`, `157_tkinter`), Kivy (`kivy`, `kivy_opencv_android`), GTK3 (`gtk3`), wxPython (`wx`, `wxpython`), PySimpleGUI (`pysimplegui`), Glumpy (`glumpy`), Datoviz (`datoviz`), Plotly (`plotly`), web frameworks like JustPy (`justpy`), Lona (`lona`), and FastHTML (`fasthtml`, `fasthtml_sse`, `fasthtml_sse_genai`, `fasthtml_fileshare`).
*   **Scientific & Numerical:** OpenCL (`cl`, incomplete), CUDA (`cuda`), Numba (`numba`), CuPy (`cupy`), JAX (`jax`, `jax_trace`, `jax_bfgs`, `jax_sort`, `jax_gemma`, `jax_render`), Opticspy (`opticspy`), Finite Difference methods (`fd_transmission_line`, `slab_waveguide_modes`), Zernike polynomials (`zernike`), FEM (`fem`), Brillouin scattering (`brillouin`).
*   **Machine Learning & AI:** FastAI (`fastai`, `fastai_language`, `fastai2_nlp`, `fastai2_again`, `colab_fastai`), Megatron-GPT (`megatron_gpt`), Makemore (`makemore`, `makemore5`), Mediapipe (`mediapipe`, `mediapipe_segment`, `mediapipe_seg`), Langchain/Azure OpenAI (`langchain_azure_openai`), OpenAI (`openai`, `openai_inofficial`), Bard (`bard`), LLM splitting (`llm_split`), general AI (`genai`), YOLO (`yolo`), Helium/Gemini integration (`helium_gemini`), MBTI analysis (`mbti`).
*   **Web & Data Scraping:** Yahoo Finance (`yahoo`), Webull (`py_webull`), SEC filings (`edgar`), Zeiss jobs (`zeiss_jobs`), general web scraping (`scrape_graph`), Playwright (`playwright`), Helium automation (`helium`).
*   **Hardware & Embedded:** MyHDL (`myhdl`), Migen (`migen`), nMigen (`nmigen`), MCH22 badge sensors/FPGA (`mch22`, `mch22_fpga`), CO2 sensor (`co2_sensor`).
*   **System & OS:** AMD desktop temperature monitoring (`temp_monitor`), ThinkPad fanspeed (`thinkpad_fanspeed`), Gentoo Linux system configuration/docker/initramfs (`gentoo`), system logs (`systemlog`).
*   **Miscellaneous:** Android development (`android_repl`, `kivy_opencv_android`, `android_automation`), Copernicus XSD parsing (incomplete), Topological Optimization (`topopt`), FreeCAD/CadQuery for 3D modeling (`freecad_part`, `cadquery`, `cadquery_optomech`, `build123d`), Star Tracker (`star_tracker`, `star_locator`), OpenCV with CUDA (`opencv_cuda`), Django web framework (`django`, `51_django`), Python in WASM (`python_wasm`), Full-text PDF indexing (`fulltext`, `pdf_db`), Generalized Adaptive Models (`ml_gam`, `spline`), Stock fair value estimation (`stock_fair_value`), LTE signal processing (`lte`), Open3D point cloud visualization (`o3d_pointcloud`), Semiconductor manufacturing problems (`semiconductor`), TOR protocol implementation (`tor`), Shadertoy shader upload (`shadertoy`), UDP holepunching (`udp_holepunch`), SQLite embedding (`sqlite_embed`), file selection GUI (`fileselect`), data scanning (`scan`), video player (`video_player`), image-to-image processing (`img2img`), `with_them_test`, magnets (`magnets`), Neostumble (`neostumble`), video hosting (`host_videos`), design patterns (`design_patterns`), Solvit2 homework (`solvit2_homework`), Lisette (`lisette`).

The project is clearly a broad exploration of transpiling Common Lisp s-expressions to Python for diverse applications, with varying levels of completion indicated for each example.




#### **A Follow-Up Idea: Training for Software Architecture**

This experiment sparked a thought. Jeremy mentioned in the lecture that LLMs are bad at software architecture because there isn't enough training data.

Perhaps we could generate such data. What if we scraped public issue trackers (Jira, GitHub Issues) and connected tickets to their corresponding pull requests? This could teach an AI how a software project actually growsâ€”how a feature request becomes code, and what kinds of changes lead to bugs later on. It seems like a scalable way to teach an AI how software is really built.
